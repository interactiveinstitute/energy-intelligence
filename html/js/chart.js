// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  this.Chart = (function() {
    Chart.SAMPLE_SIZE = 2;

    Chart.EXTRA_UNITS_ABOVE = 50;

    Chart.Y_AXIS_FACTOR = 1.2;

    Chart.Y_AXIS_MINIMUM_SIZE = 100;

    Chart.Y_AXIS_SHRINK_FACTOR = .05;

    Chart.PADDING_BOTTOM = 48;

    Chart.PADDING_TOP = 48;

    Chart.BAR_SPACING = 4;

    Chart.NOW_BAR_WIDTH = 8;

    Chart.MIN_TIME_IN_VIEW = 60 * 60 * 1000;

    Chart.MAX_TIME_IN_VIEW = 2 * 7 * 24 * 60 * 60 * 1000;

    Chart.QUICK_UPDATE = 1000;

    Chart.FULL_UPDATE = 30000;

    Chart.ENERGY_BUFFER_SIZE = 10;

    function Chart(config, db) {
      var formats,
        _this = this;
      this.config = config;
      this.db = db;
      this.design = "" + this.db + "/_design/energy_data/";
      this.feed = 'allRooms';
      this.touching = false;
      this.energyBufferTime = [];
      this.energyBufferValue = [];
      this.display = [new TotalPower(this)];
      this.x = d3.time.scale();
      this.y = d3.scale.linear().domain([0, Chart.Y_AXIS_MINIMUM_SIZE]);
      formats = [
        [
          d3.time.format('%Y'), function() {
            return true;
          }
        ], [
          d3.time.format('%b'), function(d) {
            return d.getMonth();
          }
        ], [
          d3.time.format('%b %_d'), function(d) {
            return d.getDate() !== 1;
          }
        ], [
          d3.time.format('%a %_d'), function(d) {
            return d.getDay() && d.getDate() !== 1;
          }
        ], [
          d3.time.format('%_H:%M'), function(d) {
            return d.getHours();
          }
        ], [
          d3.time.format('%_H:%M'), function(d) {
            return d.getMinutes();
          }
        ], [
          d3.time.format(':%S'), function(d) {
            return d.getSeconds();
          }
        ], [
          d3.time.format('.%L'), function(d) {
            return d.getMilliseconds();
          }
        ]
      ];
      this.xAxis = d3.svg.axis().orient('bottom').scale(this.x).ticks(10).tickPadding(6).tickFormat(function(date) {
        var f, i;
        i = formats.length - 1;
        f = formats[i];
        while (!f[1](date)) {
          f = formats[--i];
        }
        return f[0](date);
      });
      this.yAxis = d3.svg.axis().scale(this.y).orient('left').ticks(5).tickPadding(6).tickFormat(function(d) {
        return "" + d + " " + _this.display[0].unit;
      });
      this.tickDistance = 0;
      this.zoom = d3.behavior.zoom().on('zoom', function() {
        return _this.transform();
      });
    }

    Chart.prototype.getJSON = function(url) {
      var deferred, request;
      deferred = Q.defer();
      request = new XMLHttpRequest;
      request.open('GET', url, true);
      request.withCredentials = true;
      request.onload = function() {
        return deferred.resolve(JSON.parse(request.response));
      };
      request.send();
      return deferred.promise;
    };

    Chart.prototype.init = function(title, chartTitle, time, zoomer, meter, buttons, fs) {
      var button, cancel, drag, endkey, fullscreening, loadTimeout, offset, process, returnTimeout, startkey, that, url, zoom,
        _this = this;
      this.title = d3.select(title);
      this.chartTitle = d3.select(chartTitle);
      this.time = d3.select(time);
      this.zoomer = d3.select(zoomer);
      this.meter = d3.select(meter);
      this.buttons = d3.select(buttons);
      this.fullscreener = d3.select(fs);
      this.loading = this.time.select('.loading');
      this.time.call(this.zoom);
      this.toggleFullscreen(false);
      this.defaultView();
      this.display[0].init();
      returnTimeout = null;
      loadTimeout = null;
      zoom = [];
      cancel = function(timeout) {
        if (timeout != null) {
          clearTimeout(timeout);
          return timeout = null;
        }
      };
      d3.select(window).on('touchstart', function() {
        _this.touching = true;
        zoom = [_this.zoom.translate()[0], _this.zoom.scale()];
        return cancel(returnTimeout);
      }, true).on('touchmove', function() {
        return cancel(returnTimeout);
      }).on('touchend', function() {
        var timeout;
        _this.touching = false;
        cancel(loadTimeout);
        if (zoom[0] !== _this.zoom.translate()[0] || zoom[1] !== _this.zoom.scale()) {
          timeout = setTimeout((function() {
            return _this.loadData();
          }), 500);
        }
        return returnTimeout = setTimeout(function() {
          _this.fullscreener.classed('hidden', false);
          return _this.toggleFullscreen(false, function() {
            _this.transform();
            _this.autopan(_this.defaultDomain());
            return _this.loadData();
          });
        }, _this.config.default_view_after);
      }, true).on('mousewheel', function() {
        d3.event.stopPropagation();
        return d3.event.preventDefault();
      }, true);
      BubbleBath.db = this.db;
      BubbleBath.chart = this;
      BubbleBath.container = this.time.select('.bubblebath');
      that = this;
      offset = 0;
      drag = d3.behavior.drag().on('dragstart', function() {
        if (d3.touches(this).length) {
          return offset = -d3.touches(this)[0][0];
        }
      }).on('drag', function() {
        var ext, origin, position, scale, translate;
        position = (d3.event.x + offset) / (that.zoomer.node().clientWidth - this.clientWidth);
        if (position < 0) {
          position = 0;
        }
        if (position > 1) {
          position = 1;
        }
        ext = that.zoom.scaleExtent();
        scale = ext[0] + Math.pow(position, 4) * (ext[1] - ext[0]);
        origin = that.width / 2;
        translate = origin - (origin - that.zoom.translate()[0]) * scale / that.zoom.scale();
        that.zoom.translate([translate, 0]);
        that.zoom.scale(scale);
        return that.transform();
      });
      this.zoomer = d3.select('.zoomer');
      this.zoomer.select('.handle').call(drag);
      this.transform();
      this.loadData(true);
      button = this.button('overview', function() {
        _this.fullscreener.classed('hidden', false);
        _this.toggleFullscreen(false, function() {
          _this.transform();
          _this.defaultView();
          return _this.loadData();
        });
        return button.classed('active', true);
      }, true);
      this.button('watt-hours', function(showWh) {
        _this.display[0] = new (showWh ? TotalEnergy : TotalPower)(_this);
        _this.display[0].init();
        return _this.loadData();
      }, false);
      this.button('highlights', function(showHighlights) {
        return d3.select('.bubblebath').classed('withHighlights', showHighlights);
      }, true);
      this.meter.on('touchstart', function() {
        return _this.autopan(_this.defaultDomain());
      });
      fullscreening = false;
      this.fullscreener.on('touchstart', function() {
        return d3.select(this).classed('active', fullscreening = true);
      });
      d3.select('body').on('touchend', function() {
        if (!fullscreening) {
          return;
        }
        fullscreening = false;
        _this.fullscreener.classed('active', false).classed('hidden', true);
        return _this.toggleFullscreen(true, function() {
          _this.transform();
          _this.defaultView();
          return _this.loadData();
        });
      });
      process = function(doc) {
        _this.doc = doc;
        return console.log('got update', doc);
      };
      startkey = JSON.stringify([this.feed]);
      endkey = JSON.stringify([this.feed, {}]);
      url = ("" + this.db + "/_design/energy_data/_view/by_source_and_time") + ("?group_level=1&startkey=" + startkey + "&endkey=" + endkey);
      this.getJSON(url).then(function(result) {
        var source, value;
        value = result.rows[0].value;
        process({
          timestamp: +new Date(value[_this.config.at_idx]),
          ElectricPower: value[_this.config.datastream_idx.ElectricPower],
          ElectricEnergy: value[_this.config.datastream_idx.ElectricEnergy]
        });
        url = ("" + _this.db + "/_changes?filter=energy_data/") + ("measurements&include_docs=true&source=" + _this.feed);
        url = "" + url + "&feed=eventsource&since=now";
        source = new EventSource(url, {
          withCredentials: true
        });
        return source.onmessage = function(e) {
          return process(JSON.parse(e.data).doc);
        };
      });
      this.lastFullUpdate = this.lastQuickUpdate = +(new Date);
      this.scheduleUpdate();
      return setTimeout(function() {
        _this.toggleFullscreen(true, function() {
          _this.transform();
          _this.defaultView();
          return _this.loadData();
        });
        return _this.fullscreener.classed('hidden', true);
      }, 0);
    };

    Chart.prototype.energy = function(date) {
      var deferred, index, process, url,
        _this = this;
      deferred = Q.defer();
      index = this.energyBufferTime.indexOf(+date);
      if (+date > +(new Date)) {
        date = null;
      }
      if (index !== -1) {
        deferred.resolve(this.energyBufferValue[index]);
      } else {
        process = function(timestamp, power, energy) {
          var h, kW;
          kW = power / 1000;
          h = (+date - timestamp) / 1000 / 60 / 60;
          if (h > 0) {
            energy += kW * h;
          }
          _this.energyBufferTime.push(+date);
          _this.energyBufferValue.push(+energy);
          if (_this.energyBufferTime.length > Chart.ENERGY_BUFFER_SIZE) {
            _this.energyBufferTime.shift();
            _this.energyBufferValue.shift();
          }
          return deferred.resolve(energy);
        };
        if (!((date != null) || this.doc)) {
          date = +(new Date);
        }
        if (date) {
          url = ("" + this.design + "_show/unix_to_couchm_ts") + ("?feed=" + this.feed + "&timestamp=" + (+date));
          this.getJSON(url).then(function(key) {
            var endkey, startkey;
            startkey = JSON.stringify([_this.feed]);
            endkey = JSON.stringify(key);
            url = ("" + _this.design + "_view/by_source_and_time") + ("?group_level=1&startkey=" + startkey + "&endkey=" + endkey);
            return _this.getJSON(url).then(function(result) {
              var value;
              value = result.rows[0].value;
              return process(+new Date(value[_this.config.at_idx]), value[_this.config.datastream_idx.ElectricPower], value[_this.config.datastream_idx.ElectricEnergy]);
            });
          });
        } else {
          date = +(new Date);
          process(this.doc.timestamp, this.doc.ElectricPower, this.doc.ElectricEnergy);
        }
      }
      return deferred.promise;
    };

    Chart.prototype.quickUpdate = function() {
      var _base, _ref,
        _this = this;
      this.lastQuickUpdate = +(new Date);
      this.scheduleUpdate();
      if (!this.touching) {
        if ((+this.x.domain()[0] < (_ref = +(new Date)) && _ref < +this.x.domain()[1])) {
          Q.spread([this.energy(), this.energy(this.defaultDomain()[0])], function(e1, e0) {
            var energy, value;
            energy = (e1 - e0) * 1000;
            value = Math.round(energy);
            return _this.meter.select('text').text("" + value + " Wh");
          });
          if ((this.data != null) && (this.doc != null)) {
            this.data.push({
              at: new Date(this.doc.timestamp),
              resampledAt: new Date,
              value: parseFloat(this.doc.ElectricPower)
            });
            this.updateWithData();
          }
          return typeof (_base = this.display[0]).transformExtras === "function" ? _base.transformExtras() : void 0;
        }
      }
    };

    Chart.prototype.fullUpdate = function() {
      this.lastFullUpdate = this.lastQuickUpdate = +(new Date);
      this.scheduleUpdate();
      return this.loadData();
    };

    Chart.prototype.scheduleUpdate = function() {
      var untilFull, untilQuick,
        _this = this;
      untilQuick = this.lastQuickUpdate + Chart.QUICK_UPDATE - +(new Date);
      untilFull = this.lastFullUpdate + Chart.FULL_UPDATE - +(new Date);
      if (untilFull <= Chart.QUICK_UPDATE) {
        return setTimeout((function() {
          return _this.fullUpdate();
        }), untilFull);
      } else {
        return setTimeout((function() {
          return _this.quickUpdate();
        }), untilQuick);
      }
    };

    Chart.prototype.adjustToSize = function() {
      this.x.range([0, this.width]);
      this.y.range([this.height - Chart.PADDING_BOTTOM, Chart.PADDING_TOP]);
      this.xAxis.scale(this.x).tickSize(this.height);
      this.yAxis.scale(this.y).tickSize(-this.width);
      this.time.select('.x.axis').call(this.xAxis);
      this.transformYAxis();
      this.time.attr('width', this.width).attr('height', this.height);
      this.time.select('.leftGradientBox').attr('height', this.height);
      this.loading.select('rect').attr('width', this.width).attr('height', this.height);
      this.loading.select('text').attr('dx', this.width / 2).attr('dy', this.height / 2);
      return this.display[0].transform();
    };

    Chart.prototype.button = function(cls, handler, state) {
      var that;
      that = this;
      return this.buttons.append('div').classed(cls, true).classed('button', true).classed('active', state).on('touchstart', function() {
        var el;
        el = d3.select(this);
        state = !el.classed('active');
        el.classed('active', state);
        return handler.bind(that)(state, this);
      });
    };

    Chart.prototype.defaultDomain = function() {
      var end, endH, n, start, startH;
      n = new Date;
      startH = n.getHours() > this.config.work_day_hours[0] ? this.config.work_day_hours[0] : this.config.work_day_hours[0] - 24;
      start = new Date(n.getFullYear(), n.getMonth(), n.getDate(), startH);
      endH = n.getHours() < this.config.work_day_hours[0] - 1 ? this.config.work_day_hours[1] : startH + 24;
      end = new Date(n.getFullYear(), n.getMonth(), n.getDate(), endH);
      return [start, end];
    };

    Chart.prototype.defaultView = function() {
      var defaultTimeInView, domain, maxScale, minScale;
      domain = this.defaultDomain();
      this.x.domain(domain);
      defaultTimeInView = domain[1] - domain[0];
      minScale = defaultTimeInView / Chart.MAX_TIME_IN_VIEW;
      maxScale = defaultTimeInView / Chart.MIN_TIME_IN_VIEW;
      return this.zoom.x(this.x).scaleExtent([minScale, maxScale]);
    };

    Chart.prototype.autopan = function(domain) {
      var _this = this;
      this.showLoading = true;
      d3.transition().duration(1000).tween('zoom', function() {
        var interpolate, oldEnd, oldStart;
        oldStart = _this.x.domain()[0];
        oldEnd = _this.x.domain()[1];
        interpolate = d3.interpolate([+oldStart, +oldEnd], [+domain[0], +domain[1]]);
        return function(t) {
          _this.x.domain(interpolate(t));
          _this.zoom.x(_this.x);
          _this.transform();
          return BubbleBath.position();
        };
      }).each('end', function() {
        _this.showLoading = true;
        return _this.loadData(true, domain).then(function() {
          return _this.time.select('.zooms').style('opacity', 1);
        });
      });
      return this.time.select('.zooms').style('opacity', 0);
    };

    Chart.prototype.bringIntoView = function(time) {
      var add, end, interval, start, _ref;
      _ref = this.x.domain().map(function(d) {
        return +d;
      }), start = _ref[0], end = _ref[1];
      interval = end - start;
      add = 0;
      while (+time < start + add) {
        add -= interval;
      }
      while (+time > end + add) {
        add += interval;
      }
      return this.autopan([new Date(start + add), new Date(end + add)]);
    };

    Chart.prototype.transform = function() {
      var handle, scale, width, zmax, zmin, _base, _ref;
      this.transformXAxis();
      this.time.select('.zooms').attr('transform', "translate(" + (this.zoom.translate()[0]) + ", 0) scale(" + (this.zoom.scale()) + ", 1)");
      handle = this.zoomer.select('.handle').node();
      scale = this.zoom.scale();
      _ref = this.zoom.scaleExtent(), zmin = _ref[0], zmax = _ref[1];
      width = this.zoomer.node().clientWidth - handle.clientWidth;
      handle.style.left = Math.pow((scale - zmin) / (zmax - zmin), 1 / 4) * width + 'px';
      BubbleBath.position();
      return typeof (_base = this.display[0]).transformExtras === "function" ? _base.transformExtras() : void 0;
    };

    Chart.prototype.transformXAxis = function() {
      var axis, left1, left2, oi, ticks;
      axis = this.time.select('.x.axis').call(this.xAxis);
      oi = 0;
      axis.selectAll('.tick').sort(function(a, b) {
        return +a - +b;
      }).each(function(_, i) {
        if (oi === 0 && d3.select(this).classed('odd')) {
          return oi = i;
        }
      }).each(function(_, i) {
        return d3.select(this).classed('odd', oi % 2 === i % 2);
      });
      axis.selectAll('text').attr('x', 16).attr('y', this.height - 32);
      ticks = axis.selectAll('.tick');
      left1 = ticks[0][0].transform.baseVal.getItem(0).matrix.e;
      left2 = ticks[0][1].transform.baseVal.getItem(0).matrix.e;
      this.tickDistance = left2 - left1;
      return axis.selectAll('line').attr('stroke-width', this.tickDistance).attr('x1', this.tickDistance / 2).attr('x2', this.tickDistance / 2);
    };

    Chart.prototype.transformYAxis = function(transition) {
      var axis;
      if (transition == null) {
        transition = false;
      }
      axis = this.time.select('.y.axis');
      if (transition) {
        axis = axis.transition().duration(1000);
      }
      axis.call(this.yAxis);
      axis = this.time.select('.yText.axis');
      if (transition) {
        axis = axis.transition().duration(1000);
      }
      axis.call(this.yAxis);
      return axis.selectAll('text').attr('x', 5).attr('y', -16);
    };

    Chart.prototype.getTickInfo = function() {
      var date, distance, dts, i, smallest, ticks, _i, _len, _ref;
      ticks = this.time.selectAll('.x.axis .tick');
      if ((_ref = ticks[0]) != null ? _ref.length : void 0) {
        dts = [];
        ticks.each(function(d) {
          return dts.push(new Date(d));
        });
        dts = dts.sort(function(a, b) {
          return +a - +b;
        });
        smallest = Infinity;
        for (i = _i = 0, _len = dts.length; _i < _len; i = ++_i) {
          date = dts[i];
          if (i > 0) {
            distance = +date - +dts[i - 1];
            if (distance < smallest) {
              smallest = distance;
            }
          }
        }
        if (smallest < Infinity) {
          return {
            duration: smallest,
            first: dts[0]
          };
        }
      }
    };

    Chart.prototype.loadData = function(first, domain) {
      var deferred, k, params, url, v,
        _this = this;
      if (domain == null) {
        domain = this.x.domain();
      }
      deferred = Q.defer();
      params = this.display[0].getParameters(domain);
      params.feed = this.display[0].feed;
      params.datastream = this.display[0].datastream;
      url = ("" + this.db + "/_design/energy_data/_show/historical?") + ((function() {
        var _results;
        _results = [];
        for (k in params) {
          v = params[k];
          _results.push("" + k + "=" + (encodeURIComponent(v)));
        }
        return _results;
      })()).join('&');
      Q.spread([this.getJSON(url), BubbleBath.load.apply(BubbleBath, [[this.display[0].feed]].concat(__slice.call(this.x.domain())))], function(result, bubbles) {
        _this.bubbles = bubbles;
        _this.data = _this.display[0].getDataFromRequest(params, result);
        _this.updateWithData(true);
        return deferred.resolve();
      });
      if (this.showLoading) {
        this.loading.attr('opacity', .6);
        this.showLoading = false;
      }
      return deferred.promise;
    };

    Chart.prototype.updateWithData = function(stay, data, bubbles) {
      var from, newDomain, oldDomain, tempScale, to, _base;
      if (stay == null) {
        stay = false;
      }
      this.data = data != null ? data : this.data;
      this.bubbles = bubbles != null ? bubbles : this.bubbles;
      oldDomain = this.y.domain()[1];
      newDomain = d3.max(this.data.map(function(d) {
        return d.value;
      }));
      this.bubbles.each(function(d) {
        return newDomain = d3.max([newDomain, parseFloat(d.value)]);
      });
      if (newDomain === 0) {
        newDomain = Chart.Y_AXIS_MINIMUM_SIZE;
      }
      if ((oldDomain * Chart.Y_AXIS_SHRINK_FACTOR < newDomain && newDomain < oldDomain)) {
        newDomain = oldDomain;
      } else {
        newDomain *= Chart.Y_AXIS_FACTOR;
      }
      tempScale = newDomain / oldDomain;
      if (newDomain !== oldDomain) {
        this.y.domain([0, newDomain]);
        this.transformYAxis(true);
        from = "matrix(1, 0, 0,            " + tempScale + ", 0, " + ((this.height - 48) * (1 - tempScale)) + ")            scale(" + (1 / this.zoom.scale()) + ", 1)            translate(" + (-this.zoom.translate()[0]) + ", 0)";
        to = "scale(" + (1 / this.zoom.scale()) + ", 1)            translate(" + (-this.zoom.translate()[0]) + ", 0)";
        if (stay) {
          from = to;
        }
        this.display[0].setDataAndTransform(this.data, from, to);
      } else {
        to = "scale(" + (1 / this.zoom.scale()) + ", 1)            translate(" + (-this.zoom.translate()[0]) + ", 0)";
        this.display[0].setDataAndTransform(this.data, null, to, false);
      }
      if (typeof (_base = this.display[0]).transformExtras === "function") {
        _base.transformExtras();
      }
      BubbleBath.position();
      return this.loading.attr('opacity', 0);
    };

    Chart.prototype.toggleFullscreen = function(fullscreen, callback) {
      var change, height, resize, transition, width,
        _this = this;
      transition = fullscreen == null;
      this.fullscreen = fullscreen != null ? fullscreen : !this.fullscreen;
      change = function(x, y, width, height, bubbleOpacity) {
        _this.width = width;
        _this.height = height;
        _this.time.style('-webkit-transform', "translate(" + x + "px, " + y + "px)");
        _this.adjustToSize();
        return _this.time.select('.bubblebath').attr('opacity', bubbleOpacity);
      };
      resize = function(x, y, width, height, bubbleOpacity) {
        if (transition) {
          return _this.time.classed('resizing', true).style('-webkit-transform', "                  translate(" + x + "px, " + y + "px)                  scale(" + (width / _this.width) + ", " + (height / _this.height) + ")").on('webkitTransitionEnd', function() {
            d3.select(this).on('webkitTransitionEnd', null);
            change(x, y, width, height, bubbleOpacity);
            this.classList.remove('resizing');
            return typeof callback === "function" ? callback() : void 0;
          });
        } else {
          change(x, y, width, height, bubbleOpacity);
          return typeof callback === "function" ? callback() : void 0;
        }
      };
      width = document.body.clientWidth;
      height = document.body.clientHeight;
      if (this.fullscreen) {
        resize(0, 200, width, height - 366, 1);
      } else {
        resize(64 + 512, 192, width - 2 * (64 + 512), height - 192 - 32, 0);
      }
      Cardboard.toggleVisible(!this.fullscreen);
      this.title.classed('visible', !this.fullscreen);
      this.buttons.classed('visible', this.fullscreen);
      this.zoomer.classed('visible', this.fullscreen);
      this.meter.classed('fullscreen', this.fullscreen);
      return this.chartTitle.classed('fullscreen', this.fullscreen);
    };

    return Chart;

  })();

}).call(this);
